module Qualys::WAS
  # This class represents each of the WAS_SCAN_REPORT/RESULTS/VULNERABILITY_LIST/
  # VULNERABILITY elements in the Qualys WAS XML document.
  #
  # It provides a convenient way to access the information scattered all over
  # the XML in attributes and nested tags.
  #
  # Instead of providing separate methods for each supported property we rely
  # on Ruby's #method_missing to do most of the work.
  class Vulnerability
    # Accepts an XML node from Nokogiri::XML.
    def initialize(xml_node)
      @xml = xml_node
    end

    # List of supported tags. They can be attributes, simple descendans or
    # collections (e.g. <references/>, <tags/>)
    def supported_tags
      [
        # simple tags
        :access_paths, :ajax, :authentication, :ignored, :potential, :url,

        # nested tags
        :response_contents, :response_evidence, :request_headers, :request_method, :request_url
      ]
    end

    # This allows external callers (and specs) to check for implemented
    # properties
    def respond_to?(method, include_private=false)
      return true if supported_tags.include?(method.to_sym)
      super
    end

    # This method is invoked by Ruby when a method that is not defined in this
    # instance is called.
    #
    # In our case we inspect the @method@ parameter and try to find the
    # attribute, simple descendent or collection that it maps to in the XML
    # tree.
    def method_missing(method, *args)
      # We could remove this check and return nil for any non-recognized tag.
      # The problem would be that it would make tricky to debug problems with
      # typos. For instance: <>.potr would return nil instead of raising an
      # exception
      unless supported_tags.include?(method)
        super
        return
      end

      # Any fields where a simple .camelcase() won't work we need to translate,
      # this includes acronyms (e.g. :cwe would become 'Cwe') and simple nested
      # tags.
      translations_table = {
        access_paths:       'ACCESS_PATH/URL',
        request_headers:    'PAYLOADS/PAYLOAD/REQUEST/HEADERS',
        request_method:     'PAYLOADS/PAYLOAD/REQUEST/METHOD',
        request_url:        'PAYLOADS/PAYLOAD/REQUEST/URL',
        response_contents:  'PAYLOADS/PAYLOAD/RESPONSE/CONTENTS',
        response_evidence:  'PAYLOADS/PAYLOAD/RESPONSE/EVIDENCE'
      }

      method_name = translations_table.fetch(method, method.to_s.upcase)

      # Then we try simple children tags: TITLE, LAST_UPDATE, CVSS_BASE...
      tag = @xml.at_xpath("./#{method_name}")
      if tag && !tag.text.blank?
        if tags_with_base64.include?(method)
          return cleanup_base64(method_name)
        else
          return tag.text
        end      
      else
        'n/a'
      end

    end

    private

    def tags_with_base64
      [:response_contents, :response_evidence]
    end

    def cleanup_base64(field)
      return 'n/a' unless @xml.at("#{field}")

      xml_node = @xml.at("#{field}")
      result = "[unprocessable #{field}]"

      if xml_node['base64'] == 'true'
        # The force_encoding is necessary as there is non-UTF content in the strings like \xE2
        result = Base64.decode64(xml_node.text).force_encoding('UTF-8')
      else
        result = xml_node.text
      end
    end
    

  end
end
